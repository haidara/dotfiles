let g:pathogen_disabled = []
if v:version < 702
	call add(g:pathogen_disabled,'vim-autocomplpop')
endif

call pathogen#runtime_append_all_bundles()
call pathogen#helptags()

" au BufRead,BufNewFile *.php so ~/.vim/bundle/myPlugin/after/ftplugin/php.vim
" au FileType php call TextEnableCodeSnip('css', '<style', '</style', 'SpecialComment')
:au     BufRead                     changelog       set spell spelllang=en_us
" :au	    FileType                    *               set complete-=t
:au	    FileType                    *               set complete+=U
:au     BufRead                     *.js            set commentstring=//\ %s
:au     BufRead                     */doc/*.txt 	map <c-Return> <c-]>
:au     BufRead                     */doc/*.txt 	map <c-BS> 	 <c-t>
:au	    VimEnter                    *		        call ChangeDirectory()
:au     BufWritePost                .vimrc   	    so ~/.vimrc
:au     BufReadPost                 fugitive://*    set bufhidden=delete

filetype on
filetype plugin on
filetype plugin indent on
syntax on
colorschem myscheme

hi Folded	    guibg=NONE  guifg=Grey40
hi FoldColumn	guibg=NONE  guifg=LightGrey
hi User1        guifg=white guibg=red

" let g:ctags_path='/usr/bin/ctags'
" let g:ctags_statusline=1
" let g:netrw_liststyle= 1
" let php_sql_query = 1
" let php_folding = 1

" let g:tagbar_userarrows=1
" let g:CommandTMaxHeight=8
" let g:CommandTMaxFiles=3000
" set wildignore+=*.o,*.obj,test/node_modules/**
" let g:SuperTabDefaultCompletionType = "context"

"let g:snips_trigger_key='<c-j>'
"let g:snips_trigger_key_backwards='<c-space>'


"  ================================="
"   General options
"  ================================="
set guifont=Monaco:h11
set nocompatible	                    " Use Vim defaults (much better!)
set bs=start,indent,eol
set ai			                        " always set autoindenting on
set viminfo='10,\"100,:20,%
set expandtab
set shiftwidth=4
set tabstop=4
set softtabstop=4
set nobackup
"set nobackup
set ignorecase
set smartcase
set scrolloff=2
set incsearch
" set backspace=2
set backspace=start,indent,eol
set ruler
set visualbell
"set cindent
set autoindent
set smartindent
set copyindent
set shiftround
""set cinkeys=0{,0},:,0#,!,!^F
set noerrorbells
""set tw=0
""set shiftwidth=4
set report=0
set nohlsearch
"set mouse=a
set showcmd
set wildmenu
set showcmd
" add : and | to comments for newsgroups
set com+=n:\:,n:\|
set number
set nostartofline
set cpt+=]
set cursorline
""set completeopt=menu,longest,preview
set completeopt=menu,preview
""set showmatch
set hlsearch
set t_Co=256
set guioptions-=T
set history=100
set guioptions+=A
set winminheight=0
set modelines=5
set modeline
set foldmethod=indent
set foldlevel=1
set foldtext=MyFoldText()

set laststatus=2
""set statusline=%<%f %(%h%m%r %)%=%{TagName()} %{GitBranch()} %-15.15(%l,%c%V%)%P 
""set statusline=%<%f %{GitBranch()} %-15.15(%l,%c%V%)%P 
set statusline=%f       "tail of the filename
""set statusline+=[%{strlen(&fenc)?&fenc:'none'}, "file encoding
set statusline+=\ \ \ [%{&ff}] "file format
""set statusline+=%h    "help file flag
set statusline+=%1*      "Red color
set statusline+=%m       "modified flag
set statusline+=%*      "back to regula color
set statusline+=%r      "read only flag
set statusline+=%y      "filetype
set statusline+=%=      "left/right separator
" set statusline+=%1*      "Red color
"set statusline+=\ %{GitBranch()}\ 
set statusline+=\ %{fugitive#statusline()}\ 
set statusline+=%*      "Regulastatusline=%<%f %(%h%m%r %)%=%{TagName()} %-15.15(%l,%c%V%)%P%{GitBranch()} r color
set statusline+=\ \ \ \  "spaces
set statusline+=%c,     "cursor column
set statusline+=%l/%L   "cursor line/total lines
set statusline+=\ \ \ \ %P    "percent through file
set clipboard=unnamed
set autoread



"  ================================="
"   General Mappings
"  ================================="

map - :nohls<cr>
map <leader>v 			:new ~/.vimrc<CR>
map <leader>V 			:sp ~/.vim/bundle/myPlugin/<CR>
map <leader>w 			:w<cr>
map <s-up> <c-u>H
map <s-down> <c-f>H

map <leader>\ 			:q<cr>
map <leader>n 			:cn<cr>
map <leader>f :set foldmethod=indent<CR>
map <leader>F :set foldmethod=manual<CR>zE
map <leader>s :stag <c-r>=expand("<cword>")<cr><cr>
" map <C-Tab> :tag <c-r>=expand("<cword>")<cr><cr>
map <leader>c :cn<CR>
""map <leader>g :grep <cword> *<cr>
map zz zO
map '. `.

"tabs mapping
map tt :tabnew<CR>
map <C-S-Left> :tabprevious<CR>
map <C-S-Right> :tabnext<CR>
map Q gq
map <c-j> <c-w><Up>
map <c-k> <c-w><down>
map <c-p> "*p
map <c-c> "*y
map <M-Right> $
map <M-Left> 0
map + <C-W>+
map <c-\[> <c-t>
map <tab> *
map <S-tab> #
map <M-Up> <c-w>k
map <M-down> <c-w>j
map <D-Up> <c-w>k
map <D-down> <c-w>j
" map <Space><Space> :CommandT<CR>
map <leader><bar> :only<cr>
map gf :sp <cfile><cr>
map Y y$    
map ; :
map <F5> :GundoToggle<cr>
"map <c-f> /function.*
" map ww viw
map <leader>b :LustyJuggler<cr>


imap =. => 
imap -. ->
imap -0 ->
imap <M-x> <esc>
imap <M-Right> <esc>$a
imap <M-Left> <esc>0i
imap <c-space> <c-x><c-o>
imap <M-Up> <esc><c-w>k
imap <M-down> <esc><c-w>j
imap <D-Up> <esc><c-w>k
imap <D-down> <esc><c-w>j
imap zz <esc>

" visual shifting (builtin-repeat)
vnoremap . :normal .<CR>
vnoremap <M-x> <esc>
vnoremap <leader>] <ESC>`>a]<ESC>`<i[<ESC>vf]
vnoremap <leader>0 <ESC>`>a)<ESC>`<i(<ESC>vf)
vnoremap <leader>" <ESC>`>a"<ESC>`<i"<ESC>vf"
vnoremap <leader>' <ESC>`>a'<ESC>`<i'<ESC>vf'

vnoremap <tab> >gv
vnoremap <s-tab> <gv
vnoremap > >gv
vnoremap < <gv

cmap ecl e class/class.
cmap spc sp class/class.
cmap f. function.*


com! Fixnl execute "%s/\<C-M>$//e" "remove control-m characters from the end of the line

inoreabbrev ff <ESC>afor($i=0;$i<;$i++){<CR><CR>}<ESC>kkf<a
inoreabbrev func <ESC>afunction<CR>{<CR><CR>}<ESC>kkkA
inoreabbrev jqr <ESC>ajQuery(document).ready(function($){<CR>
            \$.getScript('/inc/jqfile.js',function() {<CR>});
            \<CR>});<ESC>kko


"  ================================="
"   Functions
"  ================================="

function! FixEDIFile()
	 :%s/\~HL/\~\rHL/g
	 :%s/\~/\r/g
endfunction

function! MyFoldText()
    let n = v:foldend - v:foldstart + 1
    let i = indent(v:foldstart)
    let istr = ''
    while i > 0
        let istr = istr . ' '
        let i = i - 1
    endwhile
    return istr . "+-" . v:folddashes . " " . n . " lines "
endfunction 

function! CAP_SQL()
	:%s/\<select\>/SELECT/ge
	:%s/\<insert\>/INSERT/ge
	:%s/\<update\>/UPDATE/ge
	:%s/\<delete\>/DELETE/ge
	:%s/\<where\>/WHERE/ge
	:%s/\<from\>/FROM/ge
	:%s/\<by\>/BY/ge
	:%s/\<order\>/ORDER/ge
	:%s/\<limit\>/LIMIT/ge
	:%s/\<desc\>/DESC/ge
endfunction

" Set up fancy printing
set printexpr=PrintFile(v:fname_in)
function! PrintFile(fname)
  call system("gv " . a:fname)
  call delete(a:fname)
  return v:shell_error
endfunc



" function! InsertTabWrapper()
" 	let col = col('.') - 1
" 	if !col || getline('.')[col - 1] !~ '\k'
" 		return "\<tab>"
" 	else
"         return "\<c-p>"
" 	endif
" endfunction

" inoremap <tab> <c-r>=InsertTabWrapper()<cr>


function! CompactSQLTables()
	:g/^$/d
	:g/^-/d
	normal gg
	normal /CREA<CR>
	normal f(
	normal V%J
endfunction

function! AddZZZToTemplates()
  :%s/\(VALUES (\d\{1,\},'\)/VALUES (null,'ZZZ /g 
endfunction

function! CleanFile()
	:%s//\r/g
endfunction

" Restore screen size and position.
"if has("gui_running")
"  function! ScreenFilename()
"    if has('amiga')
"      return "s:.vimsize"
"    elseif has('win32')
"      return $HOME."\\_vimsize"
"    else
"      return $HOME."/.vimsize"
"    endif
"  endfunction
"
"  function! ScreenRestore()
"    " Restore window size (columns and lines) and position
"    " from values stored in vimsize file.
"    " Must set font first so columns and lines are based on font size.
"    let f = ScreenFilename()
"    if has("gui_running") && g:restore_screen_size_pos && filereadable(f)
"      for line in readfile(f)
"        let sizepos = split(line)
"        if len(sizepos) == 5 && sizepos[0] == v:servername
"          silent! execute "set columns=".sizepos[1]." lines=".sizepos[2]
"          silent! execute "winpos ".sizepos[3]." ".sizepos[4]
"          return
"        endif
"      endfor
"    endif
"  endfunction
"
"  function! ScreenSave()
"    " Save window size and position.
"    if has("gui_running") && g:restore_screen_size_pos
"      let data = v:servername . ' ' . &columns . ' ' . &lines . ' ' .
"            \ (getwinposx()<0?0:getwinposx()) . ' ' .
"            \ (getwinposy()<0?0:getwinposy())
"      let f = ScreenFilename()
"      if filereadable(f)
"        let lines = readfile(f)
"        call filter(lines, "v:val !~ '^" . v:servername . "\\>'")
"        call add(lines, data)
"      else
"        let lines = [data]
"      endif
"      call writefile(lines, f)
"    endif
"  endfunction
"
"  if !exists('g:restore_screen_size_pos')
"    let g:restore_screen_size_pos = 1
"  endif
"  autocmd VimEnter * call ScreenRestore()
"  autocmd VimLeavePre * call ScreenSave()
"endif





"function! CurlyBracket()
" let l:startline = line(".")
" let l:result1 = searchpair('{', '', '}', 'bW')
" if (result1 > 0)
"    let l:linenum = line(".")
"    let l:string1 = substitute(getline(l:linenum), '^\s*\(.*\)\s*$', '\1', "")
"    if (l:string1 =~ '^{')
"        let l:string1 = substitute(getline(l:linenum - 1), '^\s*\(.*\)\s*$', '\1', "") . " " . l:string1
"        sil exe "normal k"
"  endif
"
" " get else part if necessary
" if (l:string1 =~ "^}")
"    sil exe "normal 0"
"    let l:result2 = searchpair('{', '', '}', 'bW')
"    if (l:result2 > 0)
"        let l:linenum = line(".")
"        let l:string2 = substitute(getline(l:linenum), '^\s*\(.*\)\s*$', '\1', "")
"        if (l:string2 =~ '^{')
"            let l:string2 = substitute(getline(l:linenum - 1), '^\s*\(.*\)\s*$', '\1', "") . " " . l:string2
"        endif
"    let l:string1 = l:string2 . " ... " . l:string1
"    endif
" endif
"
" " remove trailing whitespaces and curly brace
" let l:my_string = substitute(l:string1, '\s*{[^{]*$', '', "")
" let l:my_strlen = strlen(l:my_string)
" if (l:my_strlen > 30)
" let l:my_string = strpart(l:my_string,0,30)."..."
" endif
"
" sil exe ":" . l:startline
" sil exe "normal i}"
" if ((l:startline - l:linenum) > 10)
" sil exe "normal a /* " . l:my_string . " */"
" endif
"
" endif
"endfunction

function! ChangeDirectory()
    if isdirectory("/home/haidara/emr/www")
        :silent! cd /home/haidara/emr/www
    endif
    if isdirectory("/Users/haidara/Mounts/emr/www")
        :silent! cd /Users/haidara/Mounts/emr/www
    endif

endfunction
function! ResCur()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction

augroup resCur
  autocmd!
  autocmd BufWinEnter * call ResCur()
augroup END

" " Hax to let us have multiple highlights within a single file
" " http://vim.wikia.com/wiki/Different_syntax_highlighting_within_regions_of_a_file
" " This took me so long to find and get working properly.
" function! TextEnableCodeSnip(filetype,start,end,textSnipHl) abort "{{{
"   let ft=toupper(a:filetype)
"   let group='textGroup'.ft
"   if exists('b:current_syntax')
"     let s:current_syntax=b:current_syntax
"     " Remove current syntax definition, as some syntax files (e.g. cpp.vim)
"     " do nothing if b:current_syntax is defined.
"     unlet b:current_syntax
"   endif
"   execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
"   try
"     execute 'syntax include @'.group.' after/syntax/'.a:filetype.'.vim'
"   catch
"   endtry
"   if exists('s:current_syntax')
"     let b:current_syntax=s:current_syntax
"   else
"     unlet b:current_syntax
"   endif
"   execute 'syntax region textSnip'.ft.'
"   \ matchgroup='.a:textSnipHl.'
"   \ start="'.a:start.'" end="'.a:end.'"
"   \ contains=@'.group.'
"   \ containedin=ALL'
"   " XXX ^^ This is needed for PHP, everything in a <?PHP ... ?> block is part
"   " of a highlighting group, which breaks the rule as per vanilla in the wiki.
" endfunction "}}}

" function! FixCssHighlight()
"     call TextEnableCodeSnip('css', '<style', '</style', 'SpecialComment')
" endfunction

function! s:ListFunctions()
vimgrep /^\s*function/j %
copen
endfunction
command! -bar -narg=0 LS call s:ListFunctions()





