call pathogen#runtime_append_all_bundles()
call pathogen#helptags()

:filetype on
":au	FileType		perl				so ~/.vim/perl.vim
":au	FileType		php,html			so ~/.vim/html.vim
":au	FileType		c,cpp				so ~/.vim/c.vim
":au	FileType		java				so ~/.vim/java.vim
":au	FileType		*.jl,.sawfishrc		set ft=lisp
":au	BufReadPost		.sawmillrc			set ft=lisp
"when changing the vimrc file, reread so it's active
":au	BufWritePost 	.vimrc				so ~/.vimrc


:au	    FileType		*               :set complete-=t
:au     FileType        *               set commentstring=//\ %s
":au	    FileType		php             so ~/.vim/php.vim
:au	    FileType		php             set makeprg=php\ -l\ %
:au	    FileType		php             set errorformat=%m\ in\ %f\ on\ line\ %l
:au     BufRead			*/doc/*.txt 	map <c-Return> <c-]>
:au     BufRead			*/doc/*.txt 	map <c-BS> 	 <c-t>
:au	    VimEnter     	*		        :call ChangeDirectory()
:au     BufWritePost 	.vimrc   	    so ~/.vimrc
:au     BufReadPost fugitive://* set bufhidden=delete

" go back to where you left
""au      BufReadPost             *               if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif
""au      BufNewFile,BufRead      *.c,*.cc,*.h    imap }<CR> <Esc>:call CurlyBracket()<CR>a
""au      BufNewFile,BufRead      *.cpp,*.C       imap }<CR> <Esc>:call CurlyBracket()<CR>a
""au      BufNewFile,BufRead      *.java,*.idl    imap }<CR> <Esc>:call CurlyBracket()<CR>a
""au      BufNewFile,BufRead      *.php           imap }<CR> <Esc>:call CurlyBracket()<CR>a

"":au     BufEnter			*.php 	set filetype=javascript | set filetype=php


filetype plugin on
syntax on
colorschem myscheme

hi Folded	    guibg=NONE  guifg=Grey40
hi FoldColumn	guibg=NONE  guifg=LightGrey
hi User1        guifg=white guibg=red

let g:ctags_path='/usr/bin/ctags'
let g:ctags_statusline=1
let g:netrw_liststyle= 1
let php_sql_query = 1
let php_folding = 1

if(exists(":TagBarClose")) 
    let g:tagbar_userarrows=1
endif

if(exists(":CommandT")) 
    let g:CommandTMaxHeight=8
    set wildignore+=*.o,*.obj,test/node_modules/**
endif

if(exists(":SuperTabHelp")) 
    let g:SuperTabDefaultCompletionType = "context"
endif

"let g:snips_trigger_key='<c-j>'
"let g:snips_trigger_key_backwards='<c-space>'


"  ================================="
"   General options
"  ================================="
set nocompatible	                    " Use Vim defaults (much better!)
set bs=start,indent,eol
set ai			                        " always set autoindenting on
set viminfo='10,\"100,:20,%
set expandtab
set shiftwidth=4
set tabstop=4
set softtabstop=4
set nobackup
"set nobackup
set ignorecase
set smartcase
set scrolloff=2
set incsearch
set backspace=2
set ruler
set visualbell
""set cindent
set autoindent
set smartindent
set copyindent
set shiftround
""set cinkeys=0{,0},:,0#,!,!^F
set noerrorbells
""set tw=0
""set shiftwidth=4
set report=0
set nohlsearch
"set mouse=a
set showcmd
set wildmenu
set showcmd
" add : and | to comments for newsgroups
set com+=n:\:,n:\|
set number
set nostartofline
set cpt+=]
set cursorline
""set completeopt=menu,longest,preview
set completeopt=menu,preview
""set showmatch
set hlsearch
set t_Co=256
set guioptions-=T
set history=100
set guioptions+=A
set winminheight=0
set modelines=5
set modeline
set foldmethod=indent
set foldlevel=1
set foldtext=MyFoldText()

set laststatus=2
""set statusline=%<%f %(%h%m%r %)%=%{TagName()} %{GitBranch()} %-15.15(%l,%c%V%)%P 
""set statusline=%<%f %{GitBranch()} %-15.15(%l,%c%V%)%P 
set statusline=%t       "tail of the filename
""set statusline+=[%{strlen(&fenc)?&fenc:'none'}, "file encoding
set statusline+=\ \ \ [%{&ff}] "file format
""set statusline+=%h    "help file flag
set statusline+=%m      "modified flag
set statusline+=%r      "read only flag
set statusline+=%y      "filetype
set statusline+=%=      "left/right separator
set statusline+=%1*      "Red color
"set statusline+=\ %{GitBranch()}\ 
set statusline+=\ %{fugitive#statusline()}\ 
set statusline+=%*      "Regulastatusline=%<%f %(%h%m%r %)%=%{TagName()} %-15.15(%l,%c%V%)%P%{GitBranch()} r color
set statusline+=\ \ \ \  "spaces
set statusline+=%c,     "cursor column
set statusline+=%l/%L   "cursor line/total lines
set statusline+=\ \ \ \ %P    "percent through file
set ofu=syntaxcomplete#Complete


"  ================================="
"   General Mappings
"  ================================="

map - :nohls<cr>
map \v 			:new ~/.vimrc<CR>
map \w 			:w<cr>
map <s-up> <c-u>H
map <s-down> <c-f>H

map \\ 			:q<cr>
map K 			:silent !google-chrome "http://www.php.net/"<cword><cr>
map \n 			:cn<cr>
map \f :set foldmethod=indent<CR>
map \F :set foldmethod=manual<CR>zE
map \s :stag <c-r>=expand("<cword>")<cr><cr>
map <C-Tab> :tag <c-r>=expand("<cword>")<cr><cr>
map \c :cn<CR>
""map \g :grep <cword> *<cr>
map zz zO
map '. `.           "move to the last modification spot

"tabs mapping
map tt :tabnew<CR>
map <C-S-Left> :tabprevious<CR>
map <C-S-Right> :tabnext<CR>
map Q gq
map <c-j> <c-w><Up>
map <c-k> <c-w><down>
map <c-p> "*p
map <c-c> "*y
map <M-Right> $
map <M-Left> 0
map + <C-W>+
map <c-\[> <c-t>
map <tab> *
map <S-tab> #
map <M-Up> <c-w>k
map <M-down> <c-w>j
map <D-Up> <c-w>k
map <D-down> <c-w>j
map \g :execute "grep -R --include '*.php' --include '*.js' " . expand("<cword>") . " *" <CR> :copen<cr>
map <Space><Space> :CommandT<CR>
map \| :only<cr>

imap =. => 
imap <M-x> <esc>
imap <M-Right> <esc>$a
imap <M-Left> <esc>0i
imap <c-space> <c-x><c-o>
imap <M-Up> <esc><c-w>k
imap <M-down> <esc><c-w>j
imap <D-Up> <esc><c-w>k
imap <D-down> <esc><c-w>j
imap ss $
imap jj $j

" visual shifting (builtin-repeat)
vnoremap . :normal .<CR>
vnoremap <M-x> <esc>
vnoremap <tab> >gv
vnoremap <S-tab> <gv
vnoremap \9 <ESC>`>a)<ESC>`<i(<ESC>
vnoremap \" <ESC>`>a"<ESC>`<i"<ESC>
vnoremap \' <ESC>`>a'<ESC>`<i'<ESC>

cmap ecl e class/class.
cmap spc sp class/class.
cmap f. function.*


com! Fixnl execute "%s/\<C-M>$//e" "remove control-m characters from the end of the line

inoreabbrev ff <ESC>afor($i=0;$i<;$i++){<CR><CR>}<ESC>kkf<a
inoreabbrev func <ESC>afunction<CR>{<CR><CR>}<ESC>kkkA
inoreabbrev jqr <ESC>ajQuery(document).ready(function($){<CR>
            \$.getScript('/inc/jqfile.js',function() {<CR>});
            \<CR>});<ESC>kko


"  ================================="
"   Functions
"  ================================="

function! FixEDIFile()
	 :%s/\~HL/\~\rHL/g
	 :%s/\~/\r/g
endfunction

function! MyFoldText()
    let n = v:foldend - v:foldstart + 1
    let i = indent(v:foldstart)
    let istr = ''
    while i > 0
        let istr = istr . ' '
        let i = i - 1
    endwhile
    return istr . "+-" . v:folddashes . " " . n . " lines "
endfunction 

function! CAP_SQL()
	:%s/\<select\>/SELECT/ge
	:%s/\<insert\>/INSERT/ge
	:%s/\<update\>/UPDATE/ge
	:%s/\<delete\>/DELETE/ge
	:%s/\<where\>/WHERE/ge
	:%s/\<from\>/FROM/ge
	:%s/\<by\>/BY/ge
	:%s/\<order\>/ORDER/ge
	:%s/\<limit\>/LIMIT/ge
	:%s/\<desc\>/DESC/ge
endfunction

" Set up fancy printing
set printexpr=PrintFile(v:fname_in)
function! PrintFile(fname)
  call system("gv " . a:fname)
  call delete(a:fname)
  return v:shell_error
endfunc



"function! InsertTabWrapper()
"	let col = col('.') - 1
"	if !col || getline('.')[col - 1] !~ '\k'
"		return "\<tab>"
"	else
"        return "\<c-p>"
"	endif
"endfunction
"
"inoremap <tab> <c-r>=InsertTabWrapper()<cr>


function! CompactSQLTables()
	:g/^$/d
	:g/^-/d
	normal gg
	normal /CREA<CR>
	normal f(
	normal V%J
endfunction

function! AddZZZToTemplates()
  :%s/\(VALUES (\d\{1,\},'\)/VALUES (null,'ZZZ /g 
endfunction

function! CleanFile()
	:%s//\r/g
endfunction

" Restore screen size and position.
"if has("gui_running")
"  function! ScreenFilename()
"    if has('amiga')
"      return "s:.vimsize"
"    elseif has('win32')
"      return $HOME."\\_vimsize"
"    else
"      return $HOME."/.vimsize"
"    endif
"  endfunction
"
"  function! ScreenRestore()
"    " Restore window size (columns and lines) and position
"    " from values stored in vimsize file.
"    " Must set font first so columns and lines are based on font size.
"    let f = ScreenFilename()
"    if has("gui_running") && g:restore_screen_size_pos && filereadable(f)
"      for line in readfile(f)
"        let sizepos = split(line)
"        if len(sizepos) == 5 && sizepos[0] == v:servername
"          silent! execute "set columns=".sizepos[1]." lines=".sizepos[2]
"          silent! execute "winpos ".sizepos[3]." ".sizepos[4]
"          return
"        endif
"      endfor
"    endif
"  endfunction
"
"  function! ScreenSave()
"    " Save window size and position.
"    if has("gui_running") && g:restore_screen_size_pos
"      let data = v:servername . ' ' . &columns . ' ' . &lines . ' ' .
"            \ (getwinposx()<0?0:getwinposx()) . ' ' .
"            \ (getwinposy()<0?0:getwinposy())
"      let f = ScreenFilename()
"      if filereadable(f)
"        let lines = readfile(f)
"        call filter(lines, "v:val !~ '^" . v:servername . "\\>'")
"        call add(lines, data)
"      else
"        let lines = [data]
"      endif
"      call writefile(lines, f)
"    endif
"  endfunction
"
"  if !exists('g:restore_screen_size_pos')
"    let g:restore_screen_size_pos = 1
"  endif
"  autocmd VimEnter * call ScreenRestore()
"  autocmd VimLeavePre * call ScreenSave()
"endif





"function! CurlyBracket()
" let l:startline = line(".")
" let l:result1 = searchpair('{', '', '}', 'bW')
" if (result1 > 0)
"    let l:linenum = line(".")
"    let l:string1 = substitute(getline(l:linenum), '^\s*\(.*\)\s*$', '\1', "")
"    if (l:string1 =~ '^{')
"        let l:string1 = substitute(getline(l:linenum - 1), '^\s*\(.*\)\s*$', '\1', "") . " " . l:string1
"        sil exe "normal k"
"  endif
"
" " get else part if necessary
" if (l:string1 =~ "^}")
"    sil exe "normal 0"
"    let l:result2 = searchpair('{', '', '}', 'bW')
"    if (l:result2 > 0)
"        let l:linenum = line(".")
"        let l:string2 = substitute(getline(l:linenum), '^\s*\(.*\)\s*$', '\1', "")
"        if (l:string2 =~ '^{')
"            let l:string2 = substitute(getline(l:linenum - 1), '^\s*\(.*\)\s*$', '\1', "") . " " . l:string2
"        endif
"    let l:string1 = l:string2 . " ... " . l:string1
"    endif
" endif
"
" " remove trailing whitespaces and curly brace
" let l:my_string = substitute(l:string1, '\s*{[^{]*$', '', "")
" let l:my_strlen = strlen(l:my_string)
" if (l:my_strlen > 30)
" let l:my_string = strpart(l:my_string,0,30)."..."
" endif
"
" sil exe ":" . l:startline
" sil exe "normal i}"
" if ((l:startline - l:linenum) > 10)
" sil exe "normal a /* " . l:my_string . " */"
" endif
"
" endif
"endfunction

function! ChangeDirectory()
    if isdirectory("/home/haidara/emr/www")
        :silent! cd /home/haidara/emr/www
    endif
    if isdirectory("/Users/haidara/Mounts/emr/www")
        :silent! cd /Users/haidara/Mounts/emr/www
    endif

endfunction


